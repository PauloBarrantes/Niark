Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    COMMA
    DECREASE
    DIFFERENT
    DIVISION
    DOUBLE
    ELSE
    EQUALS
    FALSE
    FOR
    FUNCTION
    GREATER
    GREATEREQUAL
    IF
    INCREASE
    LEFTBRACKET
    LEFTKEY
    LEFTPAR
    LESSER
    LESSEREQUAL
    MULTIPLICATION
    OR
    PRINT
    PRIVATE
    PUBLIC
    READ
    RETURN
    RIGHTBRACKET
    RIGHTKEY
    RIGHTPAR
    SEMICOLON
    SUBSTRACTION
    SUM
    TRUE
    VOID
    WHILE

Grammar

Rule 0     S' -> start
Rule 1     start -> decvariable NEWLINE start
Rule 2     start -> empty
Rule 3     decvariable -> VARDECLARATION ASIGNATION INT
Rule 4     dataTypeAsignation -> NAME
Rule 5     dataTypeAsignation -> INT
Rule 6     dataTypeAsignation -> STRING
Rule 7     empty -> <empty>

Terminals, with rules where they appear

AND                  : 
ASIGNATION           : 3
COMMA                : 
DECREASE             : 
DIFFERENT            : 
DIVISION             : 
DOUBLE               : 
ELSE                 : 
EQUALS               : 
FALSE                : 
FOR                  : 
FUNCTION             : 
GREATER              : 
GREATEREQUAL         : 
IF                   : 
INCREASE             : 
INT                  : 3 5
LEFTBRACKET          : 
LEFTKEY              : 
LEFTPAR              : 
LESSER               : 
LESSEREQUAL          : 
MULTIPLICATION       : 
NAME                 : 4
NEWLINE              : 1
OR                   : 
PRINT                : 
PRIVATE              : 
PUBLIC               : 
READ                 : 
RETURN               : 
RIGHTBRACKET         : 
RIGHTKEY             : 
RIGHTPAR             : 
SEMICOLON            : 
STRING               : 6
SUBSTRACTION         : 
SUM                  : 
TRUE                 : 
VARDECLARATION       : 3
VOID                 : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear

dataTypeAsignation   : 
decvariable          : 1
empty                : 2
start                : 1 0

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . decvariable NEWLINE start
    (2) start -> . empty
    (3) decvariable -> . VARDECLARATION ASIGNATION INT
    (7) empty -> .

    VARDECLARATION  shift and go to state 4
    $end            reduce using rule 7 (empty -> .)

    start                          shift and go to state 1
    decvariable                    shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> start .



state 2

    (1) start -> decvariable . NEWLINE start

    NEWLINE         shift and go to state 5


state 3

    (2) start -> empty .

    $end            reduce using rule 2 (start -> empty .)


state 4

    (3) decvariable -> VARDECLARATION . ASIGNATION INT

    ASIGNATION      shift and go to state 6


state 5

    (1) start -> decvariable NEWLINE . start
    (1) start -> . decvariable NEWLINE start
    (2) start -> . empty
    (3) decvariable -> . VARDECLARATION ASIGNATION INT
    (7) empty -> .

    VARDECLARATION  shift and go to state 4
    $end            reduce using rule 7 (empty -> .)

    decvariable                    shift and go to state 2
    start                          shift and go to state 7
    empty                          shift and go to state 3

state 6

    (3) decvariable -> VARDECLARATION ASIGNATION . INT

    INT             shift and go to state 8


state 7

    (1) start -> decvariable NEWLINE start .

    $end            reduce using rule 1 (start -> decvariable NEWLINE start .)


state 8

    (3) decvariable -> VARDECLARATION ASIGNATION INT .

    NEWLINE         reduce using rule 3 (decvariable -> VARDECLARATION ASIGNATION INT .)

